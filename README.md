Описание функций:

1. `filter_by_state(data, state='EXECUTED')`
   - Принимает список словарей `data` и значение `state` (по умолчанию 'EXECUTED').
   - Возвращает новый список, содержащий только словари, у которых значение ключа 'state' равно заданному `state`.
   - Использует списковое включение для эффективной фильтрации.

2.`sort_by_date(data, order='desc')`
   - Принимает список словарей `data` и порядок сортировки `order` ('desc' - по убыванию, 'asc' - по возрастанию, по умолчанию 'desc').
   - Возвращает новый список, в котором исходные словари отсортированы по дате.
   - Использует `sorted` с лямбда-функцией для извлечения даты из ключа 'date' и преобразования ее в объект `datetime`.
   - Параметр `reverse` в `sorted` определяет порядок сортировки. 

  
1. `convert_date(input_date: str) -> str`
* Цель:  Эта функция конвертирует дату из формата ISO 8601 (YYYY-MM-DDTHH:MM:SS) в более привычный формат DD.MM.YYYY.
* Полезность: Такое преобразование формата даты может быть полезно для отображения информации пользователю,  в отчетах, для экспорта в другие системы, которые не работают с форматом ISO 8601.

2. `number_or_account(input_string: str) -> str`
* Цель:  Эта функция маскирует номер карты или номер счета в строке, обеспечивая некоторую конфиденциальность. Она анализирует входную строку, определяя, содержит ли она слово "Счет". В зависимости от этого, вызывается другая функция для маскировки соответствующих данных.
* Полезность: Маскировка конфиденциальных данных, таких как номера карт и счетов, крайне важна для обеспечения безопасности. Эта функция может использоваться для отображения частичной информации в логах, пользовательском интерфейсе, при этом скрывая чувствительные данные.


1. `account_mask(num_account: str) -> str`

* Цель:  Маскирует номер счета, оставляя видимыми только последние 4 цифры.
* Логика:  
    * Извлекает последние 4 символа номера счета  с помощью среза `num_account[-4:]`.
    * Возвращает строку, содержащую только эти 4 цифры. 

2. `card_mask(cards_mask: str) -> str`

* Цель: Маскирует номер карты, оставляя видимыми первые 6 цифр и последние 4 цифры. 
* Логика:
    * Формирует строку, объединяя:
        * Первые 4 цифры карты (`cards_mask[:4]`).
        * Цифры 5 и 6 (`cards_mask[4:6]`).
        * Четыре звездочки ``.
        * Последние 4 цифры карты (`cards_mask[-4:]`).

Информация о тестах :

1.Тесты, которые были написаны, проверяют правильность работы функций sort_by_date и filter_by_state из модуля processing. 

✔️ Функция sort_by_date сортирует список словарей по значению ключа "date" в порядке возрастания или убывания, в зависимости от указанного параметра order. 

✔️ Функция filter_by_state фильтрует список словарей по значению ключа "state", оставляя только те элементы, у которых значение ключа "state" соответствует указанному параметру state.

Оба теста были успешно выполнены, что говорит о корректности работы функций. 

2.Здесь показан пример использования библиотеки Pytest для написания юнит-тестов для функций sort_by_date и filter_by_state из модуля processing. 

✔️ Функция sort_by_date успешно прошла тест, где список словарей был отсортирован по дате в порядке возрастания.

✔️ Функция filter_by_state также успешно прошла тест, где оставлены только элементы с состоянием "CANCELED".

Эти тесты позволяют убедиться в корректности работы функций, их способности сортировать и фильтровать данные. 

3.Этот код содержит примеры тестов с использованием библиотеки Pytest для функций convert_date и number_or_account. 

✔️ Функция convert_date имеет параметризованный тест, где для входной даты "2018-07-11T02:26:18.671407" ожидается строка "11.07.2018". Тест проверяет корректность преобразования даты.

✔️ Функция number_or_account также имеет несколько тестов. Каждый тест проверяет различные входные данные и ожидаемый результат. Например, для входных данных "Maestro 1596837868705199" ожидается "Maestro 1596 83  5199".

***********************************************************
***********************************************************
ЛИЧНО ДЛЯ МЕНЯ:autopep8 --in-place --aggressive --aggressive src/generators.py --КОМАНДА ДЛЯ РЕМОНТА ПИП8
***********************************************************
***********************************************************

Полезная информация о генераторах и функциях:

1. **`transaction_info`**: Этот генератор чебоксары возвращает описания транзакций из списка `transactions_Cheboksary`. Он просто извлекает значение по ключу `"description"` из каждого словаря в списке и возвращает его.

2. **Пример использования `transaction_info`**: В вашем коде вы создаете список `transactions_1` с некоторыми транзакциями, затем используете `transaction_info` для получения описаний итерационно печатаете их.

3. **`filter_by_money`**: Этот генератор фильтрует операции с заданной валютой из списка `transactions_Cheboksary`. Он проверяет валюту каждой операции и возвращает только те, у которых валюта совпадает с заданной.

4. **Пример использования `filter_by_money`**: В вашем коде вы создаете список `transactions_2` с операциями в разных валютах, затем используете `filter_by_money` для фильтрации операций с долларами и выводите их ID.

5. **`card_number_generator`**: Этот генератор генерирует номера карт в указанном диапазоне, представляя их в формате "**** **** **** ****", где * - цифра. Он генерирует случайные цифры для каждой позиции в номере карты.

6. **Пример использования `card_number_generator`**: В вашем коде вы используете `card_number_generator` для генерации номеров карт в диапазоне 1-5 и выводите их с разделением по блокам по 4 цифры.


Полезная информация о тестах для генераторов:

1. test_transaction_info: Этот тест проверяет правильность работы генератора transaction_info. Вы передаете список транзакций с различными валютами и описаниями и проверяете, что генератор возвращает только описания транзакций. Ваша проверка убеждается, что описания возвращаются в правильной последовательности.

2. Продолжение test_transaction_info: В данном случае данный тест ожидает, что из заданных транзакций будут выбраны только транзакции с описаниями "Перевод организации", "Перевод со счета на счет", "Перевод с карты на карту" и т.д.

3. test_filter_by_money: Этот тест проверяет правильность работы генератора filter_by_money. Вы передаете список операций с разными валютами и фильтруете операции по валюте "USD". Затем проверяете, что первый элемент после фильтрации соответствует ожидаемой операции с валютой "USD".

4. Продолжение test_filter_by_money: В данном случае ваш тест ожидает, что после фильтрации по валюте "USD" будет найдена операция с нужной валютой, и это будет первый элемент после фильтрации.

**1. Декоратор `log`:**

* **Цель:** Этот декоратор предназначен для логирования вызовов функций. Он записывает информацию о вызовах функций в файл или в консоль.
* **Как работает:**
    * Принимает необязательный аргумент `filename`, который указывает имя файла для записи логов. Если `filename` не задан, логи выводятся в консоль.
    * Возвращает функцию-декоратор, которая принимает функцию `func` в качестве аргумента.
    * Создает внутреннюю функцию `processing`, которая:
        * Получает текущее время и форматирует его в строку.
        * Вызывает исходную функцию `func` с переданными аргументами `*args` и `**kwargs`.
        * Если вызов функции прошел успешно, формирует строку лога с информацией о времени, имени функции и статусом "ok".
        * Если возникла ошибка, формирует строку лога с информацией о времени, имени функции, типе ошибки и переданными аргументами.
        * Записывает сформированную строку лога в файл (если `filename` задан) или в консоль (если `filename` не задан).
        * Возвращает результат исходной функции `func`.

**2. Функция `my_function`:**

* **Цель:** Эта функция выполняет простое сложение двух целых чисел `x` и `y`.
* **Как работает:**
    * Принимает два целых числа `x` и `y` в качестве аргументов.
    * Возвращает сумму этих чисел (`x + y`).

**3. Использование декоратора:**

* Строка `@log(filename="mylog.txt")` перед определением функции `my_function` применяет декоратор `log` к этой функции.
* Это означает, что каждый раз, когда вызывается функция `my_function`, декоратор `log` будет записывать информацию о вызове в файл `mylog.txt`.
test_decorators Этот код представляет собой тест-функцию `test_my_function`, которая проверяет корректность работы функции `my_function`. 